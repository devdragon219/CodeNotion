import { ContractInput } from '@realgimm5/frontend-common/gql/types';
import { getStringOrNull, parseDateToString, parseMonthToMonthIndex } from '@realgimm5/frontend-common/utils';

import { ContractFormInput, SublocatedContractFormInput } from '../../interfaces/FormInputs/Contract';

export const parseContractFormInputToContractInput = (contract: ContractFormInput): ContractInput => ({
  agreementDate: parseDateToString(contract.agreementDate)!,
  anytimeTerminationWarningMonths: contract.anytimeTerminationWarningMonths,
  billingAfterTerm: contract.billing.afterTerm,
  billingAlignedToCalendarYear: contract.billing.alignedToCalendarYear,
  billingAppliesBaseFee: contract.billing.appliesBaseFee,
  billingBaseFee: contract.billing.baseFee,
  billingBaseFeeBillItemTypeId: contract.billing.baseFeeBillItemType?.id,
  billingEndDate: parseDateToString(contract.billing.endDate),
  billingNotes: getStringOrNull(contract.billing.notes),
  billingPeriod: contract.billing.period,
  billingStartDate: parseDateToString(contract.billing.startDate)!,
  billingVATRateType: contract.billing.vatRateType,
  billingWithSplitPayment: contract.billing.withSplitPayment,
  billingWithStampTax: contract.billing.withStampTax,
  counterparts: contract.counterparts.map((counterpart) => ({
    contractSharePercent: counterpart.contractSharePercent!,
    id: counterpart.counterpartId,
    isMainCounterpart: counterpart.isMainCounterpart,
    since: parseDateToString(counterpart.since)!,
    subjectId: counterpart.subject!.id,
    type: counterpart.counterpartType!,
    until: parseDateToString(counterpart.until),
  })),
  effectStartDate: parseDateToString(contract.effectStartDate)!,
  externalCode: getStringOrNull(contract.externalCode),
  firstTermDurationMonths: contract.firstTermDurationMonths,
  firstTermExpirationDate: parseDateToString(contract.firstTermExpirationDate),
  id: contract.contractId,
  internalCode: contract.internalCode,
  lastRenewalStartDate: parseDateToString(contract.lastRenewalStartDate)!,
  locatedUnits: contract.locatedUnits.map((locatedUnit) => ({
    estateSubUnitId: locatedUnit.estateSubUnit?.id,
    estateUnitId: locatedUnit.estateUnit?.id,
    id: locatedUnit.locatedUnitId,
    isMainUnit: locatedUnit.isMainUnit,
    isPartialLocation: locatedUnit.isPartialLocation,
    isRegistryUpdateEnabled: locatedUnit.isRegistryUpdateEnabled,
    surfaceSqM: locatedUnit.surfaceSqM,
  })),
  managementSubjectId: contract.managementSubject!.id,
  nonRenewalWarningMonths: contract.nonRenewalWarningMonths,
  notes: getStringOrNull(contract.notes),
  oneshotAdditions: contract.oneshotAdditions.map((oneshotAddition) => ({
    accountingItemId: oneshotAddition.accountingItem!.id,
    amount: oneshotAddition.amount!,
    billItemTypeId: oneshotAddition.billItemType!.id,
    id: oneshotAddition.oneShotAdditionId,
    installments: oneshotAddition.installments,
    isBoundToTermDay: oneshotAddition.isBoundToTermDay,
    isRentalRateVariation: oneshotAddition.isRentalRateVariation,
    notes: getStringOrNull(oneshotAddition.notes),
    startDate: parseDateToString(oneshotAddition.startDate)!,
    termEndDate: parseDateToString(oneshotAddition.termEndDate),
    termStartDate: parseDateToString(oneshotAddition.termStartDate),
    vatRateId: oneshotAddition.vatRate!.id,
  })),
  previousCode: getStringOrNull(contract.previousCode),
  ratePlans: contract.ratePlans.map((ratePlan) => ({
    id: ratePlan.ratePlanId,
    isDeclarationExpected: ratePlan.isDeclarationExpected,
    newYearlyRate: ratePlan.newYearlyRate!,
    since: parseDateToString(ratePlan.since)!,
  })),
  reason: contract.reason!,
  recoverBillsAfterSuspension: contract.recoverBillsAfterSuspension,
  recurringAdditions: contract.recurringAdditions.map((recurringAddition) => ({
    accountingItemId: recurringAddition.accountingItem!.id,
    amountPerInstallment: recurringAddition.amountPerInstallment!,
    billItemTypeId: recurringAddition.billItemType!.id,
    excludeEndMonth: parseMonthToMonthIndex(recurringAddition.excludeEndMonth),
    excludeStartMonth: parseMonthToMonthIndex(recurringAddition.excludeStartMonth),
    id: recurringAddition.recurringAdditionId,
    notes: getStringOrNull(recurringAddition.notes),
    vatRateId: recurringAddition.vatRate!.id,
  })),
  registrationTaxData: contract.registrationTax.isRegistrationTaxApplied
    ? {
        contractRegistrationCode: getStringOrNull(contract.registrationTax.contractRegistrationCode),
        exemptions: contract.registrationTax.exemption,
        firstOnlineRegistrationDate: parseDateToString(contract.registrationTax.firstOnlineRegistrationDate),
        firstRegistrationDate: parseDateToString(contract.registrationTax.firstRegistrationDate),
        firstRegistrationPeriod: contract.registrationTax.firstRegistrationPeriod!,
        incomeType: contract.registrationTax.incomeType,
        incomeTypeRLI: contract.registrationTax.incomeTypeRli,
        isAccountingManaged: contract.registrationTax.isAccountingManaged,
        isRLIModeEnabled: contract.registrationTax.isRliModeEnabled,
        isTakeoverFromPreviousSubject: contract.registrationTax.isTakeoverFromPreviousSubject,
        isVoluntarySanctionApplied: contract.registrationTax.isVoluntarySanctionApplied,
        lastOnlinePaymentDate: parseDateToString(contract.registrationTax.lastOnlinePaymentDate),
        lastPaymentDate: parseDateToString(contract.registrationTax.lastPaymentDate),
        numberOfCopies: contract.registrationTax.numberOfCopies!,
        numberOfPages: contract.registrationTax.numberOfPages!,
        paymentType: contract.registrationTax.paymentType!,
        registrationNumber: getStringOrNull(contract.registrationTax.registrationNumber),
        registrationOfficeId: contract.registrationTax.registrationOffice!.id,
        registrationSerialNumber: getStringOrNull(contract.registrationTax.registrationSerialNumber),
        registrationYear: contract.registrationTax.registrationYear,
        specialCase: contract.registrationTax.specialCase,
        takeoverDate: parseDateToString(contract.registrationTax.takeoverDate),
        takeoverLegalRepresentativeSubjectId: contract.registrationTax.takeoverLegalRepresentativeSubject?.id,
        takeoverOriginalSubjectIds: contract.registrationTax.takeoverSubjects.map(({ id }) => id),
        takeoverType: contract.registrationTax.takeoverType,
        taxableRateRatioPercent: contract.registrationTax.taxableRateRatioPercent!,
        tenantShareOfStampTaxPercent: contract.registrationTax.tenantShareOfStampTaxPercent!,
        tenantTaxSharePercent: contract.registrationTax.tenantTaxSharePercent!,
        transferResolutionAmount: contract.registrationTax.transferResolutionAmount,
      }
    : null,
  revaluationData: contract.revaluation.isRevaluationApplied
    ? {
        baseRevaluationRate: contract.revaluation.baseRevaluationRate,
        isAbsoluteRevaluationApplied: contract.revaluation.isAbsoluteRevaluationApplied,
        isBackHistoryEnabled: contract.revaluation.isBackHistoryEnabled,
        isRevaluationCalculated: contract.revaluation.isRevaluationCalculated,
        nextApplicationDate: parseDateToString(contract.revaluation.nextApplicationDate)!,
        rateType: contract.revaluation.rateType!,
        referencePeriodEnd: parseDateToString(contract.revaluation.referencePeriodEnd)!,
        referencePeriodStart: parseDateToString(contract.revaluation.referencePeriodStart)!,
        revaluationPeriodMonths: contract.revaluation.revaluationPeriodMonths!,
        revaluationSharePercent: contract.revaluation.revaluationSharePercent!,
      }
    : null,
  secondTermDurationMonths: contract.secondTermDurationMonths,
  secondTermExpirationDate: parseDateToString(contract.secondTermExpirationDate),
  securityDeposits: contract.securityDeposits.map((securityDeposit) => ({
    bankAccountId: securityDeposit.subjectBankAccount?.id,
    baseAmount: securityDeposit.baseAmount!,
    id: securityDeposit.securityDepositId,
    interestCalculationStartDate: parseDateToString(securityDeposit.interestCalculationStartDate),
    isInterestCalculated: securityDeposit.isInterestCalculated,
    isSuretyRenewable: securityDeposit.isSuretyRenewable,
    notes: getStringOrNull(securityDeposit.notes),
    since: parseDateToString(securityDeposit.since),
    subjectId: securityDeposit.subject?.id,
    suretySubjectId: securityDeposit.suretySubject?.id,
    takeoverDate: parseDateToString(securityDeposit.takeoverDate),
    type: securityDeposit.securityDepositType!,
    until: parseDateToString(securityDeposit.until),
  })),
  status: contract.status!,
  sublocatedContract: contract.sublocatedContract
    ? {
        anytimeTerminationWarningMonths: contract.sublocatedContract.anytimeTerminationWarningMonths,
        firstTermDurationMonths: contract.sublocatedContract.firstTermDurationMonths,
        firstTermExpirationDate: parseDateToString(contract.sublocatedContract.firstTermExpirationDate),
        id: contract.sublocatedContract.contractId!,
        nonRenewalWarningMonths: contract.sublocatedContract.nonRenewalWarningMonths,
        secondTermDurationMonths: contract.sublocatedContract.secondTermDurationMonths,
        secondTermExpirationDate: parseDateToString(contract.sublocatedContract.secondTermExpirationDate),
        terminationDate: parseDateToString(contract.sublocatedContract.terminationDate),
        terminator: contract.sublocatedContract.terminator,
      }
    : null,
  terminationDate: parseDateToString(contract.terminationDate),
  terminator: contract.terminator,
  transactors: contract.transactors.map((transactor) => ({
    addressId: transactor.address!.id,
    id: transactor.transactorId,
    invoiceAddressId: transactor.invoiceAddress!.id,
    isInvoiced: transactor.isInvoiced,
    since: parseDateToString(transactor.since)!,
    subjectId: transactor.subject!.id,
    transactionSharePercent: transactor.transactionSharePercent!,
    type: transactor.transactorType!,
    until: parseDateToString(transactor.until),
  })),
  typeId: contract.contractType!.id,
});

export const parseContractFormInputToContractSublocatedFormInput = (
  contract: ContractFormInput,
): SublocatedContractFormInput => ({
  agreementDate: contract.agreementDate,
  anytimeTerminationWarningMonths: contract.anytimeTerminationWarningMonths,
  contractId: contract.contractId,
  contractTypeDescription: contract.contractType?.description ?? '',
  effectStartDate: contract.effectStartDate,
  externalCode: contract.externalCode,
  firstTermDurationMonths: contract.firstTermDurationMonths,
  firstTermExpirationDate: contract.firstTermExpirationDate,
  internalCode: contract.internalCode,
  lastRenewalStartDate: contract.lastRenewalStartDate,
  managementSubjectName: contract.managementSubject?.name ?? '',
  nonRenewalWarningMonths: contract.nonRenewalWarningMonths,
  reason: contract.reason,
  secondTermDurationMonths: contract.secondTermDurationMonths,
  secondTermExpirationDate: contract.secondTermExpirationDate,
  status: contract.status,
  terminationDate: contract.terminationDate,
  terminator: contract.terminator,
});
